# 冪等: [Idempotence and how it failure-proofs your data pipeline](https://www.fivetran.com/blog/idempotence-failure-proofs-data-pipeline)

Idempotenceは、データの同期に失敗したときに、重複したデータが作成されるのを防ぐ。
データウェアハウスでは、効率化のために、個々のレコードではなく、バッチ単位でレコードをロードする。
これは、進捗が個々のレコードではなく、バッチ単位で記録されることも意味します。
データ統合の同期が中断された場合、失敗時に処理されていたレコードを正確に特定できないことが多く、同期を再開するには、データパイプラインを最新のバッチの先頭から開始しなければならないことになる。
つまり、すでに処理されたデータの一部を再度処理しなければならない。


## Challenges of resuming a broken sync without idempotence


データウェアハウスに同期させるデータのバッチが次の4つあるとします。
最初のバッチは完了し、同期（緑のバー）は2番目のバッチの途中まで進んでいます。
進捗状況を追跡するカーソル（赤い矢印）は、現在、最初のバッチの終わりに設定されています。

第1バッチ（"foo" "bar" "baz" "qux" "corge"）のすべてのレコードと、第2バッチ（"grault" "garply" "waldo"）のいくつかのレコードがロードされました。

そして、同期が途切れる。

再び再開したとき、データパイプラインはカーソルを参照し、最初のバッチは完了したが、2番目のバッチは完了していないことを認識する。2番目のバッチは再開されなければならない。


2バッチ目が終了すると、カーソルは2バッチ目の終了位置に更新される。


2バッチ目から過去に同期したレコード（この場合、「grault」、「garply」、「waldo」）がデスティネーションに再導入される（赤い行）。idempotenceがなければ、レコードは重複している。


一方、idempotenceでは、すべてのユニークなレコードが適切に識別され、重複がない。


障害には "ハード "と "ソフト "がある。上の図はハード障害で、例外が発生してプログラムが終了し、カーソルで示された場所から再び再開することを余儀なくされることを意味する。

ソフト障害は、データ同期に失敗していないにもかかわらず、破損したデータが転送先にロードされてしまうという、より悪質な障害である。ソフトエラーでは、過去のカーソルを特定し、そこにロールバックするために、人の介在と徹底的な調査が必要となる。べき等でなければ、再同期された範囲内の正しいレコードの重複はもちろん、破損したレコードの正しい値と間違った値の両方が同時に宛先に存在することになります。

## Where can data integration fail?


障害は、最新のデータスタックの次の3つのステージのいずれかで発生する可能性があります。

1. ソース。ソース：データソースが予期せず使用できなくなり、同期が中断される。
2. パイプライン。パイプラインに不具合が生じ、動作が停止することがある。
3. デスティネーション。データウェアハウスへのクエリの失敗、アップグレードやマイグレーションによって同期が中断されることがあります。

これらの不具合に共通するのは、上記のように、すでに読み込まれたデータ値がデスティネーションに再導入され、重複や矛盾が生じる可能性があるということです。

Source failures

ソースは一時的または恒久的に使用できなくなることがあります。一時的な障害は、ネットワークやクエリの障害によって発生します。恒久的な障害はフェイルオーバーを引き起こし、リソースが予期せず完全に利用できなくなり、そのリソースがセカンダリ、つまり自身のバックアップコピーに切り替わることを意味します。パイプラインがバックアップ リソースに切り替わると、すでにフェッチされたレコードの一部が再度フェッチされることがあります。


Pipeline failures


パイプラインの故障は、最も一般的な故障の種類です。一般的に、パイプラインの障害は以下のような原因で発生します。

1. インフラストラクチャーの停止（例：サーバーの停止）
2. 認証情報の誤りまたは紛失
3. リソースの制限（例：メモリリーク）
4.ソフトウェアのバグ

データパイプライン、特に従来のETLフローを運用したことがある人であれば、実際にどれだけの頻度で障害が発生するかはご存知でしょう。よりシンプルで耐久性のあるELTパイプラインでさえ、定期的に停止に見舞われます。

Destination failures and migrations

クエリに失敗した結果、デスティネーションで同期に失敗することがあります。
クエリの失敗は、リソースの制約によるものです。
ノードがビジー状態であったり、予定されたダウンタイムがあったりします。

さらに、組織は定期的にデスティネーションから別のデスティネーションにアップグレードまたは移行します。
このプロセスでは通常、古い宛先へのデータパイプラインを維持し、新しい宛先が設定されている間、そのパイプラインを稼働させます。
この新しい宛先には、古い宛先のデータのコピーが入力されますが、更新が失われないようにするため、同じレコードの一部が宛先に再導入されるように、カーソルを巻き戻す必要があります。

Idempotence means self-correction

上記の各障害に共通するテーマは、復旧のために以前のカーソルにロールバックし、ある宛先にあるレコード数を再導入する必要があるということである。べき等でなければ、この再導入はレコードの重複を引き起こし、データリポジトリの完全性を損ねる。このようなデータの整合性の問題を解決するためには、通常、人間の介入が必要である。

idempotenceとレコードを一意に識別する機能があれば、重複やそれに関連する下流の問題は発生しない。送信元、パイプライン、送信先の障害は避けられませんが、べき乗のデータパイプラインは基本的に自己修正するため、人間がデータ保全のためのフォレンジックを行う必要はほとんどありません。


## プライマリキー

- [Primary Keyをつける方向に倒したかった理由](https://zenn.dev/pei0804/articles/notes-on-transfer-from-postgresql-to-snowflake)
- [RDBMS(PostgreSQL)のデータを、DWH(Snowflake)に入れる時に、再考したPrimary keyの重要性](https://zenn.dev/pei0804/articles/notes-on-transfer-from-postgresql-to-snowflake)
- [Fivetranのダッシュボード](https://dev.classmethod.jp/articles/fivetran-dashboard/)(プライマリキーを指定するようになっている)
- [How Can I Upsert Data Using a Cloud Function](https://fivetran.com/docs/functions/faq/upsert-data) (Upsert = UPDATE or INSERT)

